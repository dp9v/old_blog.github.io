---
layout: post
title:  "Java - exceptions"
date:   2017-04-02 18:34:00 +0800
categories: Java
tags: [java, exceptions, исключения ]
author: Polkovnikov Dmitriy
description: "Краткая выжимка их спецификации Java про исключения"
---

Доброе время суток!

В ближайшее время у меня начинаются собеседоваия, поэтому я в усиленом темпе начинаю готовиться и пытаюсь читать спеку по Java.
Сейчас я рассматриваю в первую очередь темы, с которыми у меня были трудности.
Начну с тезисирования главы об исключениях. Просто потому, что она самая короткая.

### Иерархия исключений

![gras](/images/java/exceptions.bmp)

Все исключения в Java наследуются от единого суперкласса `Throwable`:

* Класс `Error` представляет собой суперкласс для всех исключений, перехват которых обчно нереален.
    Это исключения, генерируемы Java-машиной и повлиять на них пользователь не может
* Класс `Exceptions` представляет собой все исключения, при которых выполнение программы ещё возможно восстановить

Класс `Exceptions` в свою очередь делятся на 2 типа исключений: исключения времени выполнения и все остальные:

* `RuntimeException` - исключения времени выполнения представляет суперкласс для всех исключений, которые могут возникнуть в процессе вычисления выражений. Вот примеры некоторых исключений времени выполнения:
    * `NullPointerException` - вызов метода неинициализированного объекта
    * `ArithmeticException` - исключение, гененрируемое при выполнении недопустимых арифметических операций, например деление на 0 типа данных int
    * `ClassCastException` - Ошибка преобразования типов
* Не `RuntimeException` - исключения, возникающие в процессе работы программы. Примеры таких исключений:
    * `IOException` - исключения чтения/записи
    * `SQLException` - Ошибка обращения к БД
    * `InterruptedException` - Ошибка завершения исполнения потока

Все исключения делятся на 2 типа:

* Проверяемые - Исключения, обработка которых обязательна. Если инструкция, генерирующая обрабатываемое исключение, не будет обернута в блок `try-catch`, то программа не будет скомпилирована
  К проверяемым исключениям относятся все не Runtime исключения.
  Часто удобно создавать свои классы проверяемых исключений, что позволяет кастомизировать обработку исключений.
* Не проверяемые - Исключения, которые без необходимости можно не обрабатывать.
  К ним относятся все наследники `RuntimeException` и `Error`

Причины возниконовения исключений:

* Выполнение инструкции `throw`
* Синхронное обнаружение java-машиной аномальной работы программы
* Асинхронное исключение - исключение работы, которое возникает в одном из потоков программы и потенциально может произойти в любой точке программы.

Далее я не буду подробно описывать обработку исключений. Просто приведу примеры кода

#### Типичная обработка исключений

~~~ java
public abstract class B {
	public abstract void throwEx() throws Exception;
}

public class A extends B {
	public void throwEx() throws IOException {
		try {
			String s = null;
			s.length(); //Генерируется NullPointerException
		}
		catch (NullPointerException ex) {
			System.out.println("NPE");
			throw new IOException(ex);
		}
		finally {
			System.out.println("Final");
		}
	}
}
~~~
В данном примере в класссе `A` перееопределен метод `throwEx`, в котором генерируется `IOException`.
Данный блок кода скомпилируется корректно, т.к. `IOException` наследует класс `Exception`
Реузультатом вызова `throwEx()` будет сгенерировано `IOException`, а на экран будет выведено:

~~~
NPE
Final
~~~

#### Использование try-with-resources

~~~ java
try(FileWriter writer = new FileWriter("filename.txt")) {
	System.out.println("ad");
}
catch (IOException e) {
	e.printStackTrace();
}
~~~

В данном блоке кода создается новый объект `SQLConnection`.
В конце блока `try` автоматически будет вызвана функция `.close`

#### Порядок перехвата исключений

~~~ java
try {
	String s = null;
	s.length();
}
catch (Exception ex){
	throw new IOException(ex);
}
catch (IOException ex) {
	throw new IOException(ex);
}
~~~

Данный код не скомпилируется, т.к. при перехвате исключений они дожны перечисляться в порядке наследования(сначала классы наследники, а потом родители)

#### Генерация null

~~~ java
public static void main(String[] args) {
	throw null;
}
~~~

Код скомпилируется, но будет выброшено `NullPointerException`

#### throws необрабатываемых исключений

~~~ java
public void throwEx() throws NullPointerException {
		throw null;
}

public void throwEx2(){
	throwEx();
}
~~~

Код скомпилируется, т.к. компилятор не требует обработки `RuntimeException`, даже если он описан в блоке `throws`

Пока все, для первого раза хватит, в будущем возможно дополню этот пост другими примерами кода